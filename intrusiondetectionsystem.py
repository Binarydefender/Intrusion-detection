# -*- coding: utf-8 -*-
"""IntrusionDetectionSystem.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uC7Z39xylWaotmyUApbiftcPw0_f8D3i
"""



"""
Loading the google drive
---

"""

from google.colab import drive
drive.mount('/content/drive')

"""Now Defining the column names to the data"""

import pandas as pd
import numpy as np

# Naming the columns for the data set
column_names = [
    'duration',
    'protocol_type',
    'service',
    'flag',
    'src_bytes',
    'dst_bytes',
    'land',
    'wrong_fragment',
    'urgent',
    'hot',
    'num_failed_logins',
    'logged_in',
    'num_compromised',
    'root_shell',
    'su_attempted',
    'num_root',
    'num_file_creations',
    'num_shells',
    'num_access_files',
    'num_outbound_cmds',
    'is_host_login',
    'is_guest_login',
    'count',
    'srv_count',
    'serror_rate',
    'srv_serror_rate',
    'rerror_rate',
    'srv_rerror_rate',
    'same_srv_rate',
    'diff_srv_rate',
    'srv_diff_host_rate',
    'dst_host_count',
    'dst_host_srv_count',
    'dst_host_same_srv_rate',
    'dst_host_diff_srv_rate',
    'dst_host_same_src_port_rate',
    'dst_host_srv_diff_host_rate',
    'dst_host_serror_rate',
    'dst_host_srv_serror_rate',
    'dst_host_rerror_rate',
    'dst_host_srv_rerror_rate',
    'attack_type',
    'difficulty'
]

train_path = '/content/drive/MyDrive/IntrusionDetectionSystemDataSet/KDDTrain+.txt'

test_path = '/content/drive/MyDrive/IntrusionDetectionSystemDataSet/KDDTest+.txt'

names = column_names

df_train = pd.read_csv(train_path, header=None, names=column_names)

df_test = pd.read_csv(test_path, header=None, names=column_names)

print(df_train.head())

print(df_train.info())

#Combining dataset for consistant encoding
combined_df = pd.concat([df_train,df_test])

#text columns
categorical_cols = ['protocol_type','service','flag']

for col in categorical_cols:
  combined_df[col] = combined_df[col].astype('category')
  combined_df[col] = combined_df[col].cat.codes

#creating binary attach column
combined_df['attack'] = combined_df['attack_type'].apply(lambda x: 0 if x=='normal' else 1)

#we will drop the original attach type column
combined_df = combined_df.drop(['attack_type','difficulty'],axis=1)

df_train_cleaned = combined_df.iloc[:len(df_train)]
df_test_cleaned = combined_df.iloc[len(df_train):]

print("Data Cleaning completed")

#see cleaned data
print(df_train_cleaned.head())

print(df_train_cleaned.info())

print(df_train_cleaned['attack'].value_counts())



from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
import seaborn as sns
import matplotlib.pyplot as plt

#Defining features X & Y
X_train = df_train_cleaned.drop('attack', axis=1)
y_train = df_train_cleaned['attack']

x_test = df_test_cleaned.drop('attack', axis=1)
y_test = df_test_cleaned['attack']

print(f"Training features shape: {X_train.shape}")
print(f"Training labels shape: {y_train.shape}")
print(f"Testing features shape: {x_test.shape}")
print(f"Testing labels shape: {y_test.shape}")

print("Training the Random Forest Model!")

model = RandomForestClassifier(n_estimators=100,random_state=42,n_jobs=-1)
model.fit(X_train,y_train)

print("Training completed!")

#Testing the forest model

y_pred = model.predict(x_test)

print("prediction completed!")
print(f"Accuracy: {accuracy_score(y_test,y_pred)}")

"""We can see the KDDTest data gives a accuracy of 77% only thats the real problem in intrusion detections systems, So to understand our model is working properly we will create our own test case and show the result."""

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt

X = df_train_cleaned.drop('attack', axis=1)
y = df_train_cleaned['attack']


X_train_new, X_test_new, y_train_new, y_test_new = train_test_split(
    X, y, test_size=0.3, random_state=42, stratify=y
)


print(f"New training features shape: {X_train_new.shape}")
print(f"New testing features shape: {X_test_new.shape}")


print("\nTraining the model on the NEW 70% training split...")


model_final = RandomForestClassifier(n_estimators=100,
                                     random_state=42,
                                     n_jobs=-1,
                                     class_weight='balanced')

model_final.fit(X_train_new, y_train_new)
print("Model training complete.")


y_pred_final = model_final.predict(X_test_new)


print("--- FINAL MODEL RESULTS (on 70/30 Split) ---")
accuracy_final = accuracy_score(y_test_new, y_pred_final)
print("---------------------------------")
print(f"Model Accuracy: {accuracy_final * 100:.2f}%")
print("---------------------------------")

print("--- Classification Report:")
print(classification_report(y_test_new, y_pred_final, target_names=['Normal (0)', 'Attack (1)']))
print("---------------------------------")

print("--- Confusion Matrix:")
cm_final = confusion_matrix(y_test_new, y_pred_final)
plt.figure(figsize=(8, 6))
sns.heatmap(cm_final, annot=True, fmt='d', cmap='Blues',
            xticklabels=['Predicted Normal', 'Predicted Attack'],
            yticklabels=['Actual Normal', 'Actual Attack'])
plt.title('Confusion Matrix (70/30 Split of Training Data)')
plt.ylabel('Actual Label')
plt.xlabel('Predicted Label')
plt.show()

from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import seaborn as sns
import matplotlib.pyplot as plt


X_train = df_train_cleaned.drop('attack', axis=1)
y_train = df_train_cleaned['attack']
X_test = df_test_cleaned.drop('attack', axis=1)
y_test = df_test_cleaned['attack']

print("\nTraining the Random Forest model with class_weight='balanced'...")


model_balanced = RandomForestClassifier(n_estimators=100,
                                        random_state=42,
                                        n_jobs=-1,
                                        class_weight='balanced')

# Train the model on the unscaled training data
model_balanced.fit(X_train, y_train)
print("Model training complete.")



print("\nMaking predictions on the test data...")
y_pred_balanced = model_balanced.predict(X_test)
print("Predictions complete.")



print("\n--- NEW RESULTS (with Class Weight Balanced) ---")
accuracy_balanced = accuracy_score(y_test, y_pred_balanced)
print("---------------------------------")
print(f"Model Accuracy: {accuracy_balanced * 100:.2f}%")
print("---------------------------------")

print("\nClassification Report:")
print(classification_report(y_test, y_pred_balanced, target_names=['Normal (0)', 'Attack (1)']))
print("---------------------------------")

print("\nConfusion Matrix:")
cm_balanced = confusion_matrix(y_test, y_pred_balanced)
plt.figure(figsize=(8, 6))
sns.heatmap(cm_balanced, annot=True, fmt='d', cmap='Blues',
            xticklabels=['Predicted Normal', 'Predicted Attack'],
            yticklabels=['Actual Normal', 'Actual Attack'])
plt.title('Confusion Matrix (Class Weight Balanced)')
plt.ylabel('Actual Label')
plt.xlabel('Predicted Label')
plt.show()